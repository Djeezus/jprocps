#!/usr/bin/env python
"""

Simple script to decorate top-like output with Java thread names
so that they can be further scrutinized in jconsole.

"""

import sys
from argparse import ArgumentParser
from time import sleep
from re import search
from subprocess import Popen, PIPE
from itertools import groupby

class PSAndJStackMerger():

  """Return a CPU-sorted list of Java tids."""
  def _invoke_ps(self, limit=None):
    columns = ('pid', 'tid', 'euser', '%cpu', '%mem', 'comm')
    ps = Popen(['ps', '-eL', '-o', ",".join(columns)], stdout=PIPE)
  
    # Burn the first line which has the header section in it.
    ps.stdout.readline()
    output = map(lambda row: dict(zip(columns, row.split(None))), ps.stdout)
  
    exitcode = ps.wait()
    if exitcode != 0:
      raise Exception("ps returned with exit code: %d" % (exitcode))
  
    # Sort and trim.
    output = sorted(output, 
        key=lambda row: float(row['%cpu']),
        reverse=True)
    output = filter(lambda row: row['comm'] == "java", output)
    if limit != None:
      return output[0:limit]
    else:
      return output
  
  """Return a dict of tid to thread name."""
  def _get_thread_names(self, pid):
    jstack = Popen(['jstack', pid], stdout=PIPE)
    
    names = dict()
    for line in jstack.stdout:
      # jstack calls them nids and uses tid for a Java-specific concept
      # (unrelated to what ps calls a tid)
      match = search('^\"(.*?)\" .*nid=(0x[a-f0-9]+)', line)
      if match:
        thread_name = match.group(1)
        tid = int(match.group(2), 0)
        names[tid] = thread_name

    exitcode = jstack.wait()
    if exitcode != 0:
      raise Exception("jstack returned with exit code: %d" % (exitcode))

    return names
  
  """Add thread_name to a list of ps entries (and return those entries)."""
  def _decorate_ps_with_thread_name(self, ps):

    by_pid_func = lambda row: row['pid']
    ps_by_pid = sorted(ps, key=by_pid_func)
    for pid, tid_rows in groupby(ps_by_pid, key=by_pid_func):
      names = self._get_thread_names(pid)
      for tid_row in tid_rows:
        tid = int(tid_row['tid'])
        thread_name = None
        if int(pid) == tid:
          thread_name = '<main>'
        elif tid in names:
          thread_name = names[tid]
        else:
          thread_name = '???'
        tid_row['thread_name'] = thread_name

    return ps

  def list_threads(self, limit=None):
    return self._decorate_ps_with_thread_name(self._invoke_ps(limit))

class Options:

  def __init__(self, argv):
    self._argv = argv

  def parse(self):
    parser = ArgumentParser(prog=self._argv[0],
        description='top for Java threads')
    parser.add_argument('-b', '--batch', action='store_true',
        help='Run in batch mode (see top)')
    parser.add_argument('-d', '--delay', metavar='N', type=int,
        default=2,
        help='Sleep <N> seconds between runs')
    args = parser.parse_args(self._argv[1:])
    self.batch = args.batch
    self.delay = args.delay

class JTop:

  def __init__(self):
    self.merger = PSAndJStackMerger()

  def print_ps(self, ps):
    fmt = '%5s %5s %-10s %-5s %-5s %s'
    print fmt % ('PID', 'TID', 'USER', '%CPU', '%MEM', 'THREAD')
    columns = ('pid', 'tid', 'euser', '%cpu', '%mem', 'thread_name')
    for proc in ps:
      print fmt % (tuple(map(lambda key: proc[key], columns)))

  def run_once(self):
    self.print_ps(self.merger.list_threads())

  def _clear_screen(self):
    print chr(27) + '[2J'

  def run_continuously(self):
    limit = 10 # TODO: make this work like actual top
    while True:
      ps = self.merger.list_threads(limit)
      self._clear_screen()
      self.print_ps(ps)
      sleep(self.options.delay)

  def run(self, argv):
    try:
      self._run(argv)

      # Work around: http://www.velocityreviews.com/forums/t749747-help-with-a-piping-error.html
      sys.stdout.flush()
    except KeyboardInterrupt:
      sys.exit(130)
    except (IOError, OSError):
      sys.exit(141)

  def _run(self, argv):
    self.options = Options(argv)
    self.options.parse()
    if self.options.batch:
      self.run_once()
    else:
      self.run_continuously()


topRunner = JTop()
topRunner.run(sys.argv)
